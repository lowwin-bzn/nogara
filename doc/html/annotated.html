<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nogara: 構成</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- 作成： Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'検索');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>メインページ</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>構成</h1>  </div>
</div>
<div class="contents">
クラス、構造体、共用体、インタフェースの説明です。<table>
  <tr><td class="indexkey"><a class="el" href="classal__device__manager.html">al_device_manager</a></td><td class="indexvalue">OpenALのデバイスデータの初期化、解放を担当する al_device_manager::instance()を呼び出し時点から destroy関数呼出までの間、デバイス管理をする </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1mpl_1_1and__.html">and_</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classapply__vector__binary.html">apply_vector_binary&lt; E1, E2, F &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classapply__vector__unary.html">apply_vector_unary&lt; E, F &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classauto__capacitor.html">auto_capacitor&lt; T, adder_t &gt;</a></td><td class="indexvalue">設定した下限、上限まで、 一回の上昇値を指定して値変換する際に増やしていくクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structauto__push__pop__matrix.html">auto_push_pop_matrix</a></td><td class="indexvalue">行列のpush popをスコープ内で自動的に行うためのオブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structbinary__function__binder_3_01_l_00_01_r_00_01_f_07_5_08_07_a0_00_01_a1_08_00_01function_01_4.html">binary_function_binder&lt; L, R, F(*)(A0, A1), function &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structbyte__unit_1_1_byte.html">byte_unit::Byte&lt; N &gt;</a></td><td class="indexvalue">Byte数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structgrammar_1_1calculator__tag.html">grammar::calculator_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classcamera__eye.html">camera_eye</a></td><td class="indexvalue">カメラの位置、注視点、上部向きの情報を持つクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcapacitor.html">capacitor&lt; T &gt;</a></td><td class="indexvalue">設定した下限、上限までの値を格納できるクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgb_1_1color.html">rgb::color&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgba_1_1color.html">rgba::color&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgb_1_1color24.html">rgb::color24</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgba_1_1color32.html">rgba::color32</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgb_1_1invisible_1_1color__deduct.html">rgb::invisible::color_deduct&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgba_1_1invisible_1_1color__deduct.html">rgba::invisible::color_deduct&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structcolor__pack.html">color_pack&lt; Color &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1color__tag.html">vertices::color_tag</a></td><td class="indexvalue">頂点色要素タグ </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1color__type.html">vertices::color_type&lt; Color &gt;</a></td><td class="indexvalue">頂点色要素 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcolumn__equal__to.html">column_equal_to&lt; E, N &gt;</a></td><td class="indexvalue">行列の列サイズがメタ整数クラスと等しいかを返す </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcolumn__equal__to__c.html">column_equal_to_c&lt; E, N &gt;</a></td><td class="indexvalue">行列の列サイズが整数リテラルと等しいかを返す </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix__iterators_1_1column__iterator.html">matrix_iterators::column_iterator&lt; T &gt;</a></td><td class="indexvalue">行イテレータ </td></tr>
  <tr><td class="indexkey"><a class="el" href="classcolumn__minor__matrix.html">column_minor_matrix&lt; E, C &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classcolumn__vector.html">column_vector&lt; E &gt;</a></td><td class="indexvalue">列ベクトルを取り出すためのクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1cons.html">vertices::cons&lt; T, N &gt;</a></td><td class="indexvalue">リストアクセスの為の要素 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix__iterators_1_1const__column__iterator.html">matrix_iterators::const_column_iterator&lt; T &gt;</a></td><td class="indexvalue">行イテレータ </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix__iterators_1_1const__row__iterator.html">matrix_iterators::const_row_iterator&lt; T &gt;</a></td><td class="indexvalue">行イテレータ </td></tr>
  <tr><td class="indexkey"><a class="el" href="structcross2__functor.html">cross2_functor&lt; E1, E2 &gt;</a></td><td class="indexvalue">2次元ベクトルの外積を行う関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structdeduct1.html">deduct1&lt; T1 &gt;</a></td><td class="indexvalue">単項から計算結果の型を推論する </td></tr>
  <tr><td class="indexkey"><a class="el" href="structdeduct2.html">deduct2&lt; T1, T2 &gt;</a></td><td class="indexvalue">二項から計算結果の型を推論する </td></tr>
  <tr><td class="indexkey"><a class="el" href="structdeduct3.html">deduct3&lt; T1, T2, T3 &gt;</a></td><td class="indexvalue">三項から計算結果の型を推論する </td></tr>
  <tr><td class="indexkey"><a class="el" href="structdeduct4.html">deduct4&lt; T1, T2, T3, T4 &gt;</a></td><td class="indexvalue">四項から計算結果の型を推論する </td></tr>
  <tr><td class="indexkey"><a class="el" href="structdeduct5.html">deduct5&lt; T1, T2, T3, T4, T5 &gt;</a></td><td class="indexvalue">五項から計算結果の型を推論する </td></tr>
  <tr><td class="indexkey"><a class="el" href="structdeduct__to__real.html">deduct_to_real&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structsmart__ptr_1_1default__unique__ptr.html">smart_ptr::default_unique_ptr&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classdiagonal__matrix.html">diagonal_matrix&lt; T, N &gt;</a></td><td class="indexvalue">対角行列 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structdimension__equal__to.html">dimension_equal_to&lt; E, N &gt;</a></td><td class="indexvalue">ベクトルの次元数がメタ整数クラスと同じかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structdimension__equal__to__c.html">dimension_equal_to_c&lt; E, N &gt;</a></td><td class="indexvalue">ベクトルの次元数がリテラル整数と同じかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structjoint_1_1draw_child.html">joint::drawChild</a></td><td class="indexvalue">子オブジェクト全てを描画するための関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structbyte__unit_1_1_ei_b.html">byte_unit::EiB&lt; N &gt;</a></td><td class="indexvalue">EiB数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structeither__is__float.html">either_is_float&lt; T1, T2 &gt;</a></td><td class="indexvalue">右辺、もしくは左辺がfloat型か否かを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structequal__test.html">equal_test&lt; T &gt;</a></td><td class="indexvalue">実数とその他で比較方法を変える関数オブジェクト 実数の場合は2つの差分の絶対値が最小値以下かで等しいかを判定し、 それ以外は単純に == で等しいかを判定する </td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpr__column__vector.html">expr_column_vector&lt; E, N &gt;</a></td><td class="indexvalue">行列の式クラスから列ベクトルを取り出すためのクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpr__row__vector.html">expr_row_vector&lt; E, N &gt;</a></td><td class="indexvalue">行列の式クラスから行ベクトルを取り出すためのクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_011_01_4.html">expression_container&lt; T, 1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_0110_01_4.html">expression_container&lt; T, 10 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_0111_01_4.html">expression_container&lt; T, 11 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_0112_01_4.html">expression_container&lt; T, 12 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_0113_01_4.html">expression_container&lt; T, 13 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_0114_01_4.html">expression_container&lt; T, 14 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_0115_01_4.html">expression_container&lt; T, 15 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_0116_01_4.html">expression_container&lt; T, 16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_012_01_4.html">expression_container&lt; T, 2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_013_01_4.html">expression_container&lt; T, 3 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_014_01_4.html">expression_container&lt; T, 4 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_015_01_4.html">expression_container&lt; T, 5 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_016_01_4.html">expression_container&lt; T, 6 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_017_01_4.html">expression_container&lt; T, 7 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_018_01_4.html">expression_container&lt; T, 8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container_3_01_t_00_019_01_4.html">expression_container&lt; T, 9 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classexpression__container__base.html">expression_container_base&lt; C, T, N &gt;</a></td><td class="indexvalue">ベクトルに使用するコンテナの基礎 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structgrammar_1_1expression__tag.html">grammar::expression_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structexpression__tag__traits.html">expression_tag_traits&lt; E &gt;</a></td><td class="indexvalue">Expression_categoryを持たないクラスが比較対象になっても問題がないように </td></tr>
  <tr><td class="indexkey"><a class="el" href="classextend__matrix.html">extend_matrix&lt; E, R, C &gt;</a></td><td class="indexvalue">元の行列より行をR個、列をC個拡張するクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classfile__data.html">file_data</a></td><td class="indexvalue">ファイルのデータを全て読み取り、保持するクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structfile__releaser.html">file_releaser</a></td><td class="indexvalue">Smart_ptrに指定するファイル開放関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1find__from__tag.html">vertices::find_from_tag&lt; cons, tag &gt;</a></td><td class="indexvalue">タグが等しい要素を見つけるメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1find__from__tag_3_01null__type_00_01tag_01_4.html">vertices::find_from_tag&lt; null_type, tag &gt;</a></td><td class="indexvalue">タグが等しい要素を見つけるメタ関数 存在しない場合はnull_type </td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgba_1_1float__color.html">rgba::float_color&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgb_1_1float__color.html">rgb::float_color&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgba_1_1float__color__constant.html">rgba::float_color_constant&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgb_1_1float__color__constant.html">rgb::float_color_constant&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structfloat__guess.html">float_guess&lt; T &gt;</a></td><td class="indexvalue">実数の比較をする時に使用する関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structfloat__priority_3_01double_01_4.html">float_priority&lt; double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structfloat__priority_3_01float_01_4.html">float_priority&lt; float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structfloat__priority_3_01long_01double_01_4.html">float_priority&lt; long double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structformat__chank.html">format_chank</a></td><td class="indexvalue">PCMフォーマット </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1get__color__type.html">vertices::get_color_type&lt; v &gt;</a></td><td class="indexvalue">頂点情報より頂点色要素を抜き出す </td></tr>
  <tr><td class="indexkey"><a class="el" href="structget__column.html">get_column&lt; E &gt;</a></td><td class="indexvalue">行列の列サイズをメタ整数クラスで返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structget__dimension.html">get_dimension&lt; E &gt;</a></td><td class="indexvalue">ベクトルの次元数ををメタ整数クラスで返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structlight__enums_1_1get__light.html">light_enums::get_light&lt; size_t &gt;</a></td><td class="indexvalue">整数をライトの番号に変換するメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structlight__enums_1_1get__light_3_010_01_4.html">light_enums::get_light&lt; 0 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structlight__enums_1_1get__light_3_011_01_4.html">light_enums::get_light&lt; 1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structlight__enums_1_1get__light_3_012_01_4.html">light_enums::get_light&lt; 2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structlight__enums_1_1get__light_3_013_01_4.html">light_enums::get_light&lt; 3 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structlight__enums_1_1get__light_3_014_01_4.html">light_enums::get_light&lt; 4 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structlight__enums_1_1get__light_3_015_01_4.html">light_enums::get_light&lt; 5 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structlight__enums_1_1get__light_3_016_01_4.html">light_enums::get_light&lt; 6 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structlight__enums_1_1get__light_3_017_01_4.html">light_enums::get_light&lt; 7 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1get__normal__type.html">vertices::get_normal_type&lt; v &gt;</a></td><td class="indexvalue">頂点情報より法線要素を抜き出す </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1get__position__type.html">vertices::get_position_type&lt; v &gt;</a></td><td class="indexvalue">頂点情報より頂点位置要素を抜き出す </td></tr>
  <tr><td class="indexkey"><a class="el" href="structget__row.html">get_row&lt; E &gt;</a></td><td class="indexvalue">行列の行サイズをメタ整数クラスで返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structget__same__dimension.html">get_same_dimension&lt; E1, E2 &gt;</a></td><td class="indexvalue">ベクトルの次元数が等しければその次元数を返し、 違っていればコンパイルエラーとするメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1get__uv__type.html">vertices::get_uv_type&lt; v &gt;</a></td><td class="indexvalue">頂点情報よりテクスチャ座標要素を抜き出す </td></tr>
  <tr><td class="indexkey"><a class="el" href="structget__value__type.html">get_value_type&lt; T &gt;</a></td><td class="indexvalue">Tの持つvalue_typeをtypeという名に変換するメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structbyte__unit_1_1_gi_b.html">byte_unit::GiB&lt; N &gt;</a></td><td class="indexvalue">GiB数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1mpl_1_1greater__equal.html">greater_equal</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classhas__value__type.html">has_value_type&lt; T &gt;</a></td><td class="indexvalue">Value_typeという名のtypedefがあるか否かを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classimage.html">image</a></td><td class="indexvalue">基礎となる画像インタフェース 現在画像データを操作するなどは不可能 純粋な画像データコンテナである </td></tr>
  <tr><td class="indexkey"><a class="el" href="classimage__manager.html">image_manager</a></td><td class="indexvalue">画像の管理を行うクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classindex__buffer.html">index_buffer</a></td><td class="indexvalue">頂点配列インデックスを扱うクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgb_1_1integer__color.html">rgb::integer_color&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structrgba_1_1integer__color.html">rgba::integer_color&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1mpl_1_1integral__c.html">integral_c</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinterval.html">interval&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__color.html">is_color&lt; C &gt;</a></td><td class="indexvalue">色型か否かを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__color_3_01rgb_1_1color24_01_4.html">is_color&lt; rgb::color24 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__color_3_01rgb_1_1color_3_01_t_01_4_01_4.html">is_color&lt; rgb::color&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__color_3_01rgb_1_1float__color_3_01_t_01_4_01_4.html">is_color&lt; rgb::float_color&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__color_3_01rgb_1_1integer__color_3_01_t_01_4_01_4.html">is_color&lt; rgb::integer_color&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__color_3_01rgba_1_1color32_01_4.html">is_color&lt; rgba::color32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__color_3_01rgba_1_1color_3_01_t_01_4_01_4.html">is_color&lt; rgba::color&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__color_3_01rgba_1_1float__color_3_01_t_01_4_01_4.html">is_color&lt; rgba::float_color&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__color_3_01rgba_1_1integer__color_3_01_t_01_4_01_4.html">is_color&lt; rgba::integer_color&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classis__expression.html">is_expression&lt; E &gt;</a></td><td class="indexvalue">Nogara::expressionのクラスであるかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__matrix.html">is_matrix&lt; E &gt;</a></td><td class="indexvalue">式Eが行列であるかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__quaternion.html">is_quaternion&lt; E &gt;</a></td><td class="indexvalue">式Eがクォータニオンであるかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1is__same.html">is_same</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__scalar.html">is_scalar&lt; E &gt;</a></td><td class="indexvalue">Eがスカラであるかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__square__matrix.html">is_square_matrix&lt; E &gt;</a></td><td class="indexvalue">式Eが正方行列であるかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__vector.html">is_vector&lt; E &gt;</a></td><td class="indexvalue">式Eがベクトルであるかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classjoint.html">joint</a></td><td class="indexvalue">モデルを結合させるオブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="classkeyboard.html">keyboard</a></td><td class="indexvalue">キーボードの抽象化 必要最低限のキー定数しか設定していない キー定数以外のキーはシングルクォートでくくった数値と同じ 実際のキーボード操作は他のライブラリに依存する </td></tr>
  <tr><td class="indexkey"><a class="el" href="structbyte__unit_1_1_ki_b.html">byte_unit::KiB&lt; N &gt;</a></td><td class="indexvalue">KiB数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structlazy__float__priority.html">lazy_float_priority&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classlight.html">light</a></td><td class="indexvalue">光源オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="classline.html">line&lt; Vector &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1make__box__functor.html">invisible::make_box_functor&lt; Vertex &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1make__buffer__functor__base.html">invisible::make_buffer_functor_base&lt; Vertex &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classinvisible_1_1make__color_box__functor.html">invisible::make_colorBox_functor&lt; Vertex, ColorPack &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classinvisible_1_1make__normal__color_box__functor.html">invisible::make_normal_colorBox_functor&lt; Vertex, ColorPack &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classmaterial.html">material&lt; T, Initializer &gt;</a></td><td class="indexvalue">マテリアルオブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structmaterial__initializer_3_01float_01_4.html">material_initializer&lt; float &gt;</a></td><td class="indexvalue">Float型のマテリアル初期値 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structmaterial__initializer_3_01int_01_4.html">material_initializer&lt; int &gt;</a></td><td class="indexvalue">Int型のマテリアル初期値 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix.html">matrix&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix22.html">matrix22&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix33.html">matrix33&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix__and__scalar.html">matrix_and_scalar&lt; E, T, F &gt;</a></td><td class="indexvalue">左辺が行列、右辺がスカラの演算を行うクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structmatrix__and__scalar__base.html">matrix_and_scalar_base&lt; E, T, Derived &gt;</a></td><td class="indexvalue">行列とスカラの演算の基礎となるクラス 演算式は基本vector_and_scalar_bbaseを継承する 継承先クラスはT apply(unsigned) const というメンバメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix__binary.html">matrix_binary&lt; E1, E2, F &gt;</a></td><td class="indexvalue">二項演算クラス 第3テンプレート引数は static T apply(U const&amp;, V const&amp;) というクラスメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="structmatrix__binary__base.html">matrix_binary_base&lt; E1, E2, Derived &gt;</a></td><td class="indexvalue">行列の二項演算の基礎となるクラス 二項演算式は基本matrix_binary_baseを継承する 継承先クラスはT apply(unsigned, unsigned) const というメンバメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix__container.html">matrix_container&lt; T, R, C, Derived &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structmatrix__equal__to.html">matrix_equal_to&lt; E, R, C &gt;</a></td><td class="indexvalue">行列の行、列サイズがメタ整数クラスと等しいかを返す </td></tr>
  <tr><td class="indexkey"><a class="el" href="structmatrix__equal__to__c.html">matrix_equal_to_c&lt; E, R, C &gt;</a></td><td class="indexvalue">行列の行、列サイズがリテラル整数と等しいかを返す </td></tr>
  <tr><td class="indexkey"><a class="el" href="structmatrix__expression.html">matrix_expression&lt; E &gt;</a></td><td class="indexvalue">行列の式の基礎となるクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structmatrix__over__size.html">matrix_over_size&lt; E, R, C &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structmatrix__over__size__c.html">matrix_over_size_c&lt; E, R, C &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structmatrix__tag.html">matrix_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix__unary.html">matrix_unary&lt; E, F &gt;</a></td><td class="indexvalue">単項演算クラス 第3テンプレート引数は static T apply(U const&amp;, V const&amp;) というクラスメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="structmatrix__unary__base.html">matrix_unary_base&lt; E, Derived &gt;</a></td><td class="indexvalue">行列の単項演算の基礎となるクラス 単項演算式は基本matrix_binary_baseを継承する 継承先クラスはT apply(unsigned, unsigned) const というメンバメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix__vector__base.html">matrix_vector_base&lt; E, N, Iter, CIter, Derived &gt;</a></td><td class="indexvalue">行列からベクトルを取り出すクラス群 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmesh.html">mesh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classmesh__buffer.html">mesh_buffer</a></td><td class="indexvalue">VBO、IBOを関連付け、管理する </td></tr>
  <tr><td class="indexkey"><a class="el" href="structmesh__buffer__drawer.html">mesh_buffer_drawer</a></td><td class="indexvalue">バッファの描画をスコープ内で自動で行うための構造体 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structbyte__unit_1_1_mi_b.html">byte_unit::MiB&lt; N &gt;</a></td><td class="indexvalue">MiB数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classminor__matrix.html">minor_matrix&lt; E, R, C &gt;</a></td><td class="indexvalue">R, Cで指定した行, 列を除いた(E::Row - 1) * (E::Column - 1)行列 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classminor__vector.html">minor_vector&lt; E, N &gt;</a></td><td class="indexvalue">Nで指定した要素を除いた(E::Dimension - 1)次元ベクトル NがEの次元数より大きければコンパイルエラーとなる </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmodel.html">model</a></td><td class="indexvalue">3Dオブジェクトの一般型 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmodel__manager.html">model_manager</a></td><td class="indexvalue">モデル、バッファの管理を行うクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmul__matrix.html">mul_matrix&lt; E1, E2 &gt;</a></td><td class="indexvalue">行列同士の乗算クラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structno__expression__tag.html">no_expression_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structgrammar_1_1no__grammar__tag.html">grammar::no_grammar_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structsfinae__check_1_1no__type.html">sfinae_check::no_type</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1normal__tag.html">vertices::normal_tag</a></td><td class="indexvalue">法線要素タグ </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1normal__type.html">vertices::normal_type</a></td><td class="indexvalue">法線要素 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structnormalize__wrapper.html">normalize_wrapper</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1null__tag.html">vertices::null_tag</a></td><td class="indexvalue">Null要素タグ </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1null__type.html">vertices::null_type</a></td><td class="indexvalue">頂点情報が扱わない要素であれば作用しないようにするための構造体 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classobject3_d.html">object3D</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classogg__stream.html">ogg_stream</a></td><td class="indexvalue">Oggファイルのストリーム再生を行うクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structover__column.html">over_column&lt; E, N &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structover__column__c.html">over_column_c&lt; E, N &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structover__row.html">over_row&lt; E, N &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structover__row__c.html">over_row_c&lt; E, N &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classpause__interpolate.html">pause_interpolate&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structbyte__unit_1_1_pi_b.html">byte_unit::PiB&lt; N &gt;</a></td><td class="indexvalue">PiB数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classpng__image.html">png_image</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1position__tag.html">vertices::position_tag</a></td><td class="indexvalue">頂点位置要素タグ </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1position__type.html">vertices::position_type</a></td><td class="indexvalue">頂点位置要素 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structposition__vertex.html">position_vertex</a></td><td class="indexvalue">頂点位置のみを扱う頂点情報 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classpow__functor.html">pow_functor&lt; T &gt;</a></td><td class="indexvalue">ベクトルの冪乗を行う関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqimage__image.html">qimage_image</a></td><td class="indexvalue">Qtの画像クラスに依存した画像クラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classquaternion.html">quaternion&lt; T &gt;</a></td><td class="indexvalue">クォータニオンクラス ベクトルとして扱っているが、vector4と順序的な互換性はない </td></tr>
  <tr><td class="indexkey"><a class="el" href="structquaternion__accessor.html">quaternion_accessor&lt; E &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classquaternion__conj.html">quaternion_conj&lt; E &gt;</a></td><td class="indexvalue">クォータニオンの共役関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="classquaternion__cross.html">quaternion_cross&lt; E1, E2 &gt;</a></td><td class="indexvalue">クォータニオンの外積関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structquaternion__same.html">quaternion_same&lt; E1, E2 &gt;</a></td><td class="indexvalue">両辺がクォータニオンであるかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structquaternion__tag.html">quaternion_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classray.html">ray&lt; V &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classrect.html">rect&lt; T &gt;</a></td><td class="indexvalue">矩形クラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classref__reverse__vector.html">ref_reverse_vector&lt; E &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classref__swizzle__vector.html">ref_swizzle_vector&lt; E, Seq &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structgrammar_1_1reference__tag.html">grammar::reference_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classrender__system.html">render_system</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classrepeat__matrix.html">repeat_matrix&lt; E, R, C &gt;</a></td><td class="indexvalue">式Eの行をR回、列をC回繰り返す行列 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structresult__is__reference.html">result_is_reference&lt; E &gt;</a></td><td class="indexvalue">Referenceが参照であるかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classreverse__vector.html">reverse_vector&lt; E &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structrow__equal__to.html">row_equal_to&lt; E, N &gt;</a></td><td class="indexvalue">行列の行サイズがメタ整数クラスと等しいかを返す </td></tr>
  <tr><td class="indexkey"><a class="el" href="structrow__equal__to__c.html">row_equal_to_c&lt; E, N &gt;</a></td><td class="indexvalue">行列の行サイズがリテラル整数と等しいかを返す </td></tr>
  <tr><td class="indexkey"><a class="el" href="classmatrix__iterators_1_1row__iterator.html">matrix_iterators::row_iterator&lt; T &gt;</a></td><td class="indexvalue">行イテレータ </td></tr>
  <tr><td class="indexkey"><a class="el" href="classrow__minor__matrix.html">row_minor_matrix&lt; E, R &gt;</a></td><td class="indexvalue">Rで指定した行を除いた(E::Row - 1) * E::Column行列 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classrow__vector.html">row_vector&lt; E &gt;</a></td><td class="indexvalue">行ベクトルを取り出すためのクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classrt__minor__matrix.html">rt_minor_matrix&lt; E &gt;</a></td><td class="indexvalue">実行時に小行列にするクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__column.html">same_column&lt; E1, E2 &gt;</a></td><td class="indexvalue">両辺の列サイズが等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__column__equal__to.html">same_column_equal_to&lt; E1, E2, N &gt;</a></td><td class="indexvalue">両辺の列サイズが等しく、メタ整数クラスNと等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__column__equal__to__c.html">same_column_equal_to_c&lt; E1, E2, N &gt;</a></td><td class="indexvalue">両辺の列サイズが等しく、リテラル整数Nと等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__dimension.html">same_dimension&lt; E1, E2 &gt;</a></td><td class="indexvalue">ベクトルの次元数が等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__dimension__equal__to.html">same_dimension_equal_to&lt; E1, E2, N &gt;</a></td><td class="indexvalue">ベクトルの次元数が等しく、指定した数値リテラルとも等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__expr__tag.html">same_expr_tag&lt; E, tag &gt;</a></td><td class="indexvalue">式Eの種類がtagと等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__row.html">same_row&lt; E1, E2 &gt;</a></td><td class="indexvalue">両辺の行サイズが等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__row__column.html">same_row_column&lt; E1, E2 &gt;</a></td><td class="indexvalue">両辺の行、列サイズが等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__row__column__equal__to.html">same_row_column_equal_to&lt; E1, E2, R, C &gt;</a></td><td class="indexvalue">両辺の行、列サイズが等しく、メタ数値クラスR, Cと等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__row__column__equal__to__c.html">same_row_column_equal_to_c&lt; E1, E2, R, C &gt;</a></td><td class="indexvalue">両辺の行、列サイズが等しく、リテラル数値R, Cと等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__row__equal__to.html">same_row_equal_to&lt; E1, E2, N &gt;</a></td><td class="indexvalue">両辺の行サイズが等しく、メタ整数クラスNと等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsame__row__equal__to__c.html">same_row_equal_to_c&lt; E1, E2, N &gt;</a></td><td class="indexvalue">両辺の行サイズが等しく、リテラル整数と等しいかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structscalar__abs.html">scalar_abs&lt; T &gt;</a></td><td class="indexvalue">Abs関数の関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="classscalar__and__matrix.html">scalar_and_matrix&lt; T, E, F &gt;</a></td><td class="indexvalue">左辺がスカラ、右辺が行列の演算を行うクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classscalar__and__vector.html">scalar_and_vector&lt; T, E, F &gt;</a></td><td class="indexvalue">左辺がスカラ、右辺がベクトルの演算を行うクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structscalar__binary__functor.html">scalar_binary_functor&lt; L, R &gt;</a></td><td class="indexvalue">二項演算の戻り値型推論や引数の参照を定義するクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1scalar__binary__functor__c.html">invisible::scalar_binary_functor_c&lt; L, R &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1scalar__binary__functor__impl.html">invisible::scalar_binary_functor_impl&lt; L, R &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structscalar__identity.html">scalar_identity&lt; T &gt;</a></td><td class="indexvalue">+演算子の関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structscalar__inverse.html">scalar_inverse&lt; T &gt;</a></td><td class="indexvalue">逆数の関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structscalar__negate.html">scalar_negate&lt; T &gt;</a></td><td class="indexvalue">-演算子の関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structscalar__unary__functor.html">scalar_unary_functor&lt; T &gt;</a></td><td class="indexvalue">単項演算の戻り値型推論や引数の参照を定義するクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1scalar__unary__functor__c.html">invisible::scalar_unary_functor_c&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1scalar__unary__functor__impl.html">invisible::scalar_unary_functor_impl&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classscalar__vector.html">scalar_vector&lt; T, N &gt;</a></td><td class="indexvalue">一つの値のみで構成されているベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqimage__image_1_1send__data.html">qimage_image::send_data</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structsfinae__check.html">sfinae_check</a></td><td class="indexvalue">SFINAEの制御に使う簡易なtypedefとそのインタフェース 実装はこの構造体を継承するか、 yes_type, no_typeだけを使用する </td></tr>
  <tr><td class="indexkey"><a class="el" href="classshader__container.html">shader_container</a></td><td class="indexvalue">シェーダの管理機構 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classslice__matrix.html">slice_matrix&lt; E, Rows, Columns &gt;</a></td><td class="indexvalue">式Eの部分行列 Rowsは行の範囲 Columnsは列の範囲を示す </td></tr>
  <tr><td class="indexkey"><a class="el" href="classslice__vector.html">slice_vector&lt; E, Range &gt;</a></td><td class="indexvalue">ベクトルからRangeの範囲を抜き出すクラス 結果サイズはRangeのサイズになる。 Rangeがの始点から終点がベクトルを超過するようであればコンパイルエラー </td></tr>
  <tr><td class="indexkey"><a class="el" href="structslicer.html">slicer&lt; x, y &gt;</a></td><td class="indexvalue">範囲を切り出す時に使用するクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classsound__buffer.html">sound_buffer&lt; Resource &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classsound__buffer__base.html">sound_buffer_base</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classsound__manager.html">sound_manager</a></td><td class="indexvalue">音声データのグループを複数管理するクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classsound__resource.html">sound_resource&lt; Format &gt;</a></td><td class="indexvalue">ファイルからRCMフォーマット、データを読み取る </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsource__binder.html">source_binder</a></td><td class="indexvalue">バッファに音源情報を割り当てる </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsquare__equal__to.html">square_equal_to&lt; E, N &gt;</a></td><td class="indexvalue">式Eが正方行列かつメタ整数クラスNと等しい大きさかを返すメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structsquare__equal__to__c.html">square_equal_to_c&lt; E, N &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1swizzle__get__index.html">invisible::swizzle_get_index&lt; item &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1swizzle__get__index__impl.html">invisible::swizzle_get_index_impl&lt; item, is_void &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1swizzle__get__index__impl_3_01item_00_01false_01_4.html">invisible::swizzle_get_index_impl&lt; item, false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1swizzle__indices.html">invisible::swizzle_indices&lt; Seq &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classswizzle__vector.html">swizzle_vector&lt; E, Seq &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1tag__traits__impl.html">invisible::tag_traits_impl&lt; E, b &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1tag__traits__impl_3_01_e_00_01true_01_4.html">invisible::tag_traits_impl&lt; E, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structgrammar_1_1terminal__tag.html">grammar::terminal_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classtexture.html">texture</a></td><td class="indexvalue">テクスチャバッファ管理クラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structtexture__auto__drawer.html">texture_auto_drawer</a></td><td class="indexvalue">テクスチャのバインド、バインド解除をスコープ内で自動で行う構造体 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classtexture__board.html">texture_board</a></td><td class="indexvalue">テクスチャを描画する矩形オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structbyte__unit_1_1_ti_b.html">byte_unit::TiB&lt; N &gt;</a></td><td class="indexvalue">TiB数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classtransformation.html">transformation&lt; T &gt;</a></td><td class="indexvalue">移動、回転、スケーリングを行う変換行列 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classtranspose__matrix.html">transpose_matrix&lt; E &gt;</a></td><td class="indexvalue">転置行列クラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classtriangle.html">triangle&lt; Vector &gt;</a></td><td class="indexvalue">三角形クラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1mpl_1_1if___1_1type.html">type</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classinvisible_1_1color__deduct_1_1type.html">type</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structtype__to__gl__type.html">type_to_gl_type&lt; T &gt;</a></td><td class="indexvalue">組み込み型をOpenGLの型を示す数値に変換するメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structunary__function__binder_3_01_t_00_01_f_07_5_08_07_a0_08_00_01function_01_4.html">unary_function_binder&lt; T, F(*)(A0), function &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1uv__tag.html">vertices::uv_tag</a></td><td class="indexvalue">テクスチャ座標要素タグ </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertices_1_1uv__type.html">vertices::uv_type</a></td><td class="indexvalue">テクスチャ座標要素 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvalue__type__wrapper.html">value_type_wrapper&lt; T &gt;</a></td><td class="indexvalue">Tをvalue_typeという名に変換するメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector1.html">vector1&lt; T &gt;</a></td><td class="indexvalue">1次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector10.html">vector10&lt; T &gt;</a></td><td class="indexvalue">10次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector11.html">vector11&lt; T &gt;</a></td><td class="indexvalue">11次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector12.html">vector12&lt; T &gt;</a></td><td class="indexvalue">12次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector13.html">vector13&lt; T &gt;</a></td><td class="indexvalue">13次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector14.html">vector14&lt; T &gt;</a></td><td class="indexvalue">14次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector15.html">vector15&lt; T &gt;</a></td><td class="indexvalue">15次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector16.html">vector16&lt; T &gt;</a></td><td class="indexvalue">16次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector2.html">vector2&lt; T &gt;</a></td><td class="indexvalue">2次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector3.html">vector3&lt; T &gt;</a></td><td class="indexvalue">3次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector4.html">vector4&lt; T &gt;</a></td><td class="indexvalue">4次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector5.html">vector5&lt; T &gt;</a></td><td class="indexvalue">5次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector6.html">vector6&lt; T &gt;</a></td><td class="indexvalue">6次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector7.html">vector7&lt; T &gt;</a></td><td class="indexvalue">7次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector8.html">vector8&lt; T &gt;</a></td><td class="indexvalue">8次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector9.html">vector9&lt; T &gt;</a></td><td class="indexvalue">9次元ベクトルクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector__and__scalar.html">vector_and_scalar&lt; E, T, F &gt;</a></td><td class="indexvalue">左辺がベクトル、右辺がスカラの演算を行うクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__and__scalar__base.html">vector_and_scalar_base&lt; E, T, Derived &gt;</a></td><td class="indexvalue">ベクトルとスカラの演算の基礎となるクラス 演算式は基本vector_and_scalar_bbaseを継承する 継承先クラスはT apply(unsigned) const というメンバメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector__binary.html">vector_binary&lt; E1, E2, F &gt;</a></td><td class="indexvalue">二項演算クラス 第3テンプレート引数は static T apply(U const&amp;, V const&amp;)という クラスメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__binary__base.html">vector_binary_base&lt; E1, E2, E &gt;</a></td><td class="indexvalue">ベクトルの二項演算の基礎となるクラス 二項演算式は基本vector_binary_baseを継承する 継承先クラスはT apply(unsigned) const という メンバメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector__binary__to__scalar.html">vector_binary_to_scalar&lt; E1, E2, F &gt;</a></td><td class="indexvalue">二項のベクトルからスカラを演算するクラス Fは static T apply(E1, E2)という staticメンバメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector__binary__to__scalar__base.html">vector_binary_to_scalar_base&lt; E1, E2, Derived &gt;</a></td><td class="indexvalue">二項のベクトルからスカラを演算するクラスの基礎 二項演算式は基本vector_binary_to_scalar_baseを継承する 継承先クラスはT apply() const という メンバメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__container.html">vector_container&lt; V, T &gt;</a></td><td class="indexvalue">ベクトルの基本的動作を記述したクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector__cross_3_01_l_00_01_r_00_012_01_4.html">vector_cross&lt; L, R, 2 &gt;</a></td><td class="indexvalue">外積関数オブジェクトの2次元ベクトル特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector__cross_3_01_l_00_01_r_00_013_01_4.html">vector_cross&lt; L, R, 3 &gt;</a></td><td class="indexvalue">外積関数オブジェクトの3次元ベクトル特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector__cross_3_01_l_00_01_r_00_014_01_4.html">vector_cross&lt; L, R, 4 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__expression.html">vector_expression&lt; E &gt;</a></td><td class="indexvalue">ベクトル式の基礎となるクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__expression__tag.html">vector_expression_tag&lt; E1, E2 &gt;</a></td><td class="indexvalue">ベクトルの次元数が等しければベクトルの種類(ベクトル, クォータニオン)を返し、 違っていればコンパイルエラーとするメタ関数 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector__iterator.html">vector_iterator&lt; T &gt;</a></td><td class="indexvalue">ベクトル式で使用するイテレータ </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector__lerp__functor.html">vector_lerp_functor&lt; T0 &gt;</a></td><td class="indexvalue">線形補間を行う関数オブジェクト </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__tag.html">vector_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structinvisible_1_1vector__tag__impl.html">invisible::vector_tag_impl&lt; E1, E2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type.html">vector_type&lt; T, N &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 後に特殊化する </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_0110_01_4.html">vector_type&lt; T, 10 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 10次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_0111_01_4.html">vector_type&lt; T, 11 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 11次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_0112_01_4.html">vector_type&lt; T, 12 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 12次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_0113_01_4.html">vector_type&lt; T, 13 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 13次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_0114_01_4.html">vector_type&lt; T, 14 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 14次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_0115_01_4.html">vector_type&lt; T, 15 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 15次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_0116_01_4.html">vector_type&lt; T, 16 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 16次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_012_01_4.html">vector_type&lt; T, 2 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 2次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_013_01_4.html">vector_type&lt; T, 3 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 3次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_014_01_4.html">vector_type&lt; T, 4 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 4次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_015_01_4.html">vector_type&lt; T, 5 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 5次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_016_01_4.html">vector_type&lt; T, 6 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 6次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_017_01_4.html">vector_type&lt; T, 7 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 7次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_018_01_4.html">vector_type&lt; T, 8 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 8次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__type_3_01_t_00_019_01_4.html">vector_type&lt; T, 9 &gt;</a></td><td class="indexvalue">次元数と等しいベクトル型を返す 9次元ベクトルに対する特殊化 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvector__unary.html">vector_unary&lt; E, F &gt;</a></td><td class="indexvalue">単項演算クラス 第3テンプレート引数は static T apply(T const&amp;)という クラスメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvector__unary__base.html">vector_unary_base&lt; E, Derived &gt;</a></td><td class="indexvalue">単項演算の基礎となるクラス 単項演算式は基本vector_unary_baseを継承する 継承先クラスはT apply(unsigned) const という メンバメソッドを持つ必要がある </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertex1.html">vertex1&lt; T1 &gt;</a></td><td class="indexvalue">頂点位置 + 一つの要素を扱う頂点情報 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertex2.html">vertex2&lt; T1, T2 &gt;</a></td><td class="indexvalue">頂点位置 + 二つの要素を扱う頂点情報 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structvertex3.html">vertex3&lt; T1, T2, T3 &gt;</a></td><td class="indexvalue">頂点位置 + 三つの要素を扱う頂点情報 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classvertex__buffer.html">vertex_buffer</a></td><td class="indexvalue">VBOを扱うためのクラス </td></tr>
  <tr><td class="indexkey"><a class="el" href="classwave__format.html">wave_format</a></td><td class="indexvalue">Waveフォーマット </td></tr>
  <tr><td class="indexkey"><a class="el" href="structwrrap__get__value__type.html">wrrap_get_value_type&lt; T &gt;</a></td><td class="indexvalue">Tがvalue_typeという名のtypedefを持っていればそのまま、 持っていなければ付随してget_value_typeに渡すメタ関数 </td></tr>
</table>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>全て</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>クラス</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>ネームスペース</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>ファイル</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>関数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>変数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>型定義</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>列挙型</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Nogaraに対してFri Apr 29 2011 06:50:03に生成されました。&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
