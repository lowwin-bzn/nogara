<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nogara: include/nogara/expression/vector/function.hpp ソースファイル</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- 作成： Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'検索');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>メインページ</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li class="current"><a href="files.html"><span>ファイル</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>ファイル一覧</span></a></li>
      <li><a href="globals.html"><span>ファイルメンバ</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>include/nogara/expression/vector/function.hpp</h1>  </div>
</div>
<div class="contents">
<a href="vector_2function_8hpp.html">説明を見る。</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef NOGARA_EXPRESSION_VECTOR_FUNCTION_HPP</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define NOGARA_EXPRESSION_VECTOR_FUNCTION_HPP</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;boost/mpl/size_t.hpp&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;boost/mpl/greater.hpp&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;boost/utility/enable_if.hpp&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;boost/function_types/function_type.hpp&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;boost/function_types/parameter_types.hpp&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;boost/mpl/at.hpp&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;<a class="code" href="vector__and__scalar_8hpp.html" title="ベクトルとスカラの演算を行うクラス">nogara/expression/vector/vector_and_scalar.hpp</a>&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;<a class="code" href="vector__to__scalar_8hpp.html" title="ベクトルを演算し、スカラにするクラス">nogara/expression/vector/vector_to_scalar.hpp</a>&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;<a class="code" href="apply_8hpp.html" title="ベクトルの要素に対し関数適用するベクトル">nogara/expression/vector/apply.hpp</a>&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;<a class="code" href="vector_2minor_8hpp.html" title="一要素を除くベクトルを返すクラス">nogara/expression/vector/minor.hpp</a>&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;<a class="code" href="swizzle_8hpp.html" title="要素参照入れ替えベクトル">nogara/expression/vector/swizzle.hpp</a>&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;<a class="code" href="vector_2functor_8hpp.html" title="ベクトルで使用する関数オブジェクト群">nogara/expression/vector/functor.hpp</a>&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="value__type__traits_8hpp.html" title="value_typeに関するメタ関数群">nogara/type_traits/value_type_traits.hpp</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="function_8hpp.html" title="ベクトル、行列等で使用されるクラス群">nogara/expression/function.hpp</a>&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 __NOGARA_EXPRESSION_BEGIN
<a name="l00027"></a>00027 
<a name="l00032"></a>00032 <span class="keyword">template</span>&lt;std::<span class="keywordtype">size_t</span> N, <span class="keyword">class</span> E&gt;
<a name="l00033"></a>00033 <span class="keyword">inline</span> <span class="keyword">typename</span> boost::lazy_enable_if&lt;
<a name="l00034"></a>00034     boost::mpl::greater&lt;get_dimension&lt;E&gt;, boost::mpl::size_t&lt;N&gt; &gt;,
<a name="l00035"></a>00035     nogara::get_value_type&lt;E&gt; &gt;<a class="code" href="classboost_1_1mpl_1_1if___1_1type.html">::type</a>
<a name="l00036"></a><a class="code" href="vector__fwd_8hpp.html#a979cc01b0e4913103432bb520f254d57">00036</a> <span class="keyword">get</span>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; e){<span class="keywordflow">return</span> e()(N);}
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="keyword">template</span>&lt;std::<span class="keywordtype">size_t</span> N, <span class="keyword">class</span> E&gt;
<a name="l00039"></a>00039 <span class="keyword">inline</span> <span class="keyword">typename</span> boost::enable_if&lt;
<a name="l00040"></a>00040     boost::mpl::and_&lt;boost::mpl::greater&lt;get_dimension&lt;E&gt;, boost::mpl::size_t&lt;N&gt; &gt;,
<a name="l00041"></a>00041                      <a class="code" href="structresult__is__reference.html" title="referenceが参照であるかを返すメタ関数">result_is_reference&lt;E&gt;</a>, boost::mpl::not_&lt;boost::is_const&lt;E&gt; &gt; &gt;,
<a name="l00042"></a>00042     <span class="keyword">typename</span> E::reference&gt;<a class="code" href="classboost_1_1mpl_1_1if___1_1type.html">::type</a>
<a name="l00043"></a>00043 <span class="keyword">get</span>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a>&amp; e){<span class="keywordflow">return</span> e()(N);}
<a name="l00044"></a>00044 
<a name="l00048"></a>00048 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Result, <span class="keyword">class</span> E1, <span class="keyword">class</span> E2&gt;
<a name="l00049"></a><a class="code" href="vector_2function_8hpp.html#aefffa6b2a1e7c648909ae24862294c12">00049</a> <span class="keyword">inline</span> Result <a class="code" href="matrix_2function_8hpp.html#aa7b8b9cf669bb5ce3b6f90b1172b0cc1" title="式の三項演算関数、式は評価される">ternary</a>(<span class="keywordtype">bool</span> then,
<a name="l00050"></a>00050                       <a class="code" href="structvector__expression.html">vector_expression&lt;E1&gt;</a> <span class="keyword">const</span>&amp; e1,
<a name="l00051"></a>00051                       <a class="code" href="structvector__expression.html">vector_expression&lt;E2&gt;</a> <span class="keyword">const</span>&amp; e2)
<a name="l00052"></a>00052 {
<a name="l00053"></a>00053     <span class="keywordflow">return</span> then ? Result(e1) : Result(e2);
<a name="l00054"></a>00054 }
<a name="l00055"></a>00055 
<a name="l00059"></a>00059 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E&gt;
<a name="l00060"></a>00060 <span class="keyword">inline</span> <a class="code" href="classapply__vector__unary.html">apply_vector_unary&lt;E, typename E::value_type (*)(typename E::value_type)&gt;</a>
<a name="l00061"></a><a class="code" href="vector_2function_8hpp.html#a326fb720c990be8264d819cf88c114b6">00061</a> <a class="code" href="vector_2function_8hpp.html#a326fb720c990be8264d819cf88c114b6" title="ベクトルの値それぞれを絶対値にしたベクトルを返す関数">abs</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; val){
<a name="l00062"></a>00062     <span class="keyword">typedef</span> <span class="keyword">typename</span> E::value_type T;
<a name="l00063"></a>00063     <span class="keywordflow">return</span> apply&lt;T, T&gt;(val, <a class="code" href="vector_2function_8hpp.html#a326fb720c990be8264d819cf88c114b6" title="ベクトルの値それぞれを絶対値にしたベクトルを返す関数">std::abs</a>);
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00069"></a>00069 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E&gt;
<a name="l00070"></a><a class="code" href="vector_2function_8hpp.html#ac2900d0e7ae939f67fad07aebfe2a432">00070</a> <span class="keyword">inline</span> <span class="keyword">typename</span> E::value_type <a class="code" href="vector_2function_8hpp.html#ac2900d0e7ae939f67fad07aebfe2a432" title="ベクトルの値から最大値を返す関数">max</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; e){
<a name="l00071"></a>00071     <span class="keyword">typedef</span> <span class="keyword">typename</span> E::value_type <span class="keyword">const</span>&amp; c_ref;
<a name="l00072"></a>00072     <span class="keywordflow">return</span> reduce&lt;c_ref, c_ref, c_ref&gt;(e, <a class="code" href="vector_2function_8hpp.html#ac2900d0e7ae939f67fad07aebfe2a432" title="ベクトルの値から最大値を返す関数">std::max</a>);
<a name="l00073"></a>00073 }
<a name="l00074"></a>00074 
<a name="l00078"></a>00078 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E&gt;
<a name="l00079"></a><a class="code" href="vector_2function_8hpp.html#ac7580ae21610ca73f5e30826bc9562df">00079</a> <span class="keyword">inline</span> <span class="keyword">typename</span> E::value_type <a class="code" href="vector_2function_8hpp.html#ac7580ae21610ca73f5e30826bc9562df" title="ベクトルの値から最小値を返す関数">min</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; e){
<a name="l00080"></a>00080     <span class="keyword">typedef</span> <span class="keyword">typename</span> E::value_type <span class="keyword">const</span>&amp; c_ref;
<a name="l00081"></a>00081     <span class="keywordflow">return</span> reduce&lt;c_ref, c_ref, c_ref&gt;(e, <a class="code" href="vector_2function_8hpp.html#ac7580ae21610ca73f5e30826bc9562df" title="ベクトルの値から最小値を返す関数">std::min</a>);
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 
<a name="l00087"></a>00087 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E&gt;
<a name="l00088"></a><a class="code" href="vector_2function_8hpp.html#aec6e88d2bdf5259da50482edfc75b3c6">00088</a> <span class="keyword">inline</span> <span class="keyword">typename</span> E::value_type <a class="code" href="vector_2function_8hpp.html#aec6e88d2bdf5259da50482edfc75b3c6" title="ベクトルの合計を返す関数">sum</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; e){
<a name="l00089"></a>00089     <span class="keywordflow">return</span> reduce(e, std::plus&lt;typename E::value_type&gt;());
<a name="l00090"></a>00090 }
<a name="l00091"></a>00091 
<a name="l00095"></a>00095 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E1, <span class="keyword">class</span> E2&gt;
<a name="l00096"></a>00096 <span class="keyword">inline</span> <span class="keyword">typename</span> deduct2&lt;E1, E2&gt;::value_type
<a name="l00097"></a><a class="code" href="vector_2function_8hpp.html#ac98bdedfa67670e68c93891a11aaf738">00097</a> <a class="code" href="vector_2function_8hpp.html#ac98bdedfa67670e68c93891a11aaf738" title="内積関数">dot</a>(<a class="code" href="structvector__expression.html">vector_expression&lt;E1&gt;</a> <span class="keyword">const</span>&amp; e1, <a class="code" href="structvector__expression.html">vector_expression&lt;E2&gt;</a> <span class="keyword">const</span>&amp; e2){
<a name="l00098"></a>00098     <span class="keywordflow">return</span> <a class="code" href="vector_2function_8hpp.html#aec6e88d2bdf5259da50482edfc75b3c6" title="ベクトルの合計を返す関数">sum</a>(<a class="code" href="vector_2function_8hpp.html#a7cec8ed4a1cf975a46f92a23b4865725" title="要素同士の乗算関数">multiply</a>(e1, e2));
<a name="l00099"></a>00099 }
<a name="l00100"></a>00100 
<a name="l00104"></a>00104 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1, <span class="keyword">class</span> E2&gt;
<a name="l00105"></a>00105 <span class="keyword">inline</span> <span class="keyword">typename</span> boost::enable_if&lt;
<a name="l00106"></a>00106     <a class="code" href="structsame__dimension.html" title="ベクトルの次元数が等しいかを返すメタ関数">same_dimension&lt;E1, E2&gt;</a>, vector_cross&lt;E1, E2, get_dimension&lt;E1&gt;::value&gt; &gt;<a class="code" href="classboost_1_1mpl_1_1if___1_1type.html">::type</a>
<a name="l00107"></a><a class="code" href="vector_2functor_8hpp.html#ad4d6e7bca417cd891b73b5a06ab839af">00107</a> <a class="code" href="vector_2function_8hpp.html#a969104624180693e480251a38ba55eb4" title="外積関数">cross</a>(<a class="code" href="structvector__expression.html">vector_expression&lt;E1&gt;</a> <span class="keyword">const</span>&amp; e1, <a class="code" href="structvector__expression.html">vector_expression&lt;E2&gt;</a> <span class="keyword">const</span>&amp; e2){
<a name="l00108"></a>00108     <span class="keywordflow">return</span> vector_cross&lt;E1, E2, get_dimension&lt;E1&gt;::value&gt;(e1, e2);
<a name="l00109"></a>00109 }
<a name="l00110"></a>00110 
<a name="l00114"></a>00114 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E1, <span class="keyword">class</span> E2&gt;
<a name="l00115"></a>00115 <span class="keyword">inline</span> <a class="code" href="classvector__binary.html" title="二項演算クラス 第3テンプレート引数は static T apply(U const&amp;amp;, V const&amp;amp;)という クラスメソッドを持つ必要がある">vector_binary&lt;E1, E2, scalar_mul&lt;E1, E2&gt;</a> &gt;
<a name="l00116"></a><a class="code" href="vector_2function_8hpp.html#a7cec8ed4a1cf975a46f92a23b4865725">00116</a> <a class="code" href="vector_2function_8hpp.html#a7cec8ed4a1cf975a46f92a23b4865725" title="要素同士の乗算関数">multiply</a>(<a class="code" href="structvector__expression.html">vector_expression&lt;E1&gt;</a> <span class="keyword">const</span>&amp; v1, <a class="code" href="structvector__expression.html">vector_expression&lt;E2&gt;</a> <span class="keyword">const</span>&amp; v2){
<a name="l00117"></a>00117     <span class="keywordflow">return</span> <a class="code" href="classvector__binary.html" title="二項演算クラス 第3テンプレート引数は static T apply(U const&amp;amp;, V const&amp;amp;)という クラスメソッドを持つ必要がある">vector_binary&lt;E1, E2, scalar_mul&lt;E1, E2&gt;</a> &gt;(v1, v2);
<a name="l00118"></a>00118 }
<a name="l00119"></a>00119 
<a name="l00123"></a>00123 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E1, <span class="keyword">class</span> E2&gt;
<a name="l00124"></a>00124 <span class="keyword">inline</span> <a class="code" href="classvector__binary.html" title="二項演算クラス 第3テンプレート引数は static T apply(U const&amp;amp;, V const&amp;amp;)という クラスメソッドを持つ必要がある">vector_binary&lt;E1, E2, scalar_mul&lt;E1, E2&gt;</a> &gt;
<a name="l00125"></a><a class="code" href="vector_2function_8hpp.html#af9c11b7750e12b5e442517c266c77cfe">00125</a> <a class="code" href="vector_2function_8hpp.html#af9c11b7750e12b5e442517c266c77cfe" title="要素同士の除算関数">divide</a>(<a class="code" href="structvector__expression.html">vector_expression&lt;E1&gt;</a> <span class="keyword">const</span>&amp; v1, <a class="code" href="structvector__expression.html">vector_expression&lt;E2&gt;</a> <span class="keyword">const</span>&amp; v2){
<a name="l00126"></a>00126     <span class="keywordflow">return</span> <a class="code" href="classvector__binary.html" title="二項演算クラス 第3テンプレート引数は static T apply(U const&amp;amp;, V const&amp;amp;)という クラスメソッドを持つ必要がある">vector_binary&lt;E1, E2, scalar_mul&lt;E1, E2&gt;</a> &gt;(v1, v2);
<a name="l00127"></a>00127 }
<a name="l00128"></a>00128 
<a name="l00132"></a>00132 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E&gt;
<a name="l00133"></a>00133 <span class="keyword">inline</span> <span class="keyword">typename</span> deduct1&lt;E&gt;::value_type
<a name="l00134"></a><a class="code" href="vector_2function_8hpp.html#a885888cb99ca98818df7dd40abbe13a2">00134</a> <a class="code" href="vector_2function_8hpp.html#a885888cb99ca98818df7dd40abbe13a2" title="ベクトルの大きさの二乗を返す関数">length_sq</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; value){
<a name="l00135"></a>00135     <span class="keywordflow">return</span> <a class="code" href="vector_2function_8hpp.html#ac98bdedfa67670e68c93891a11aaf738" title="内積関数">nogara::expression::dot</a>(value, value);
<a name="l00136"></a>00136 }
<a name="l00137"></a>00137 
<a name="l00141"></a>00141 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00142"></a>00142 <span class="keyword">inline</span> <span class="keyword">typename</span> deduct1&lt;T&gt;::real_type
<a name="l00143"></a><a class="code" href="vector_2function_8hpp.html#a54d5268004fe199763337f2179a7608e">00143</a> <a class="code" href="vector_2function_8hpp.html#a54d5268004fe199763337f2179a7608e" title="ベクトル大きさを返す関数">length</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;T&gt;</a> <span class="keyword">const</span>&amp; value){
<a name="l00144"></a>00144     <span class="keyword">using</span> std::sqrt;
<a name="l00145"></a>00145     <span class="keywordflow">return</span> sqrt(<a class="code" href="vector_2function_8hpp.html#a885888cb99ca98818df7dd40abbe13a2" title="ベクトルの大きさの二乗を返す関数">nogara::expression::length_sq</a>(value));
<a name="l00146"></a>00146 }
<a name="l00147"></a>00147 
<a name="l00151"></a>00151 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E1, <span class="keyword">class</span> E2&gt;
<a name="l00152"></a>00152 <span class="keyword">inline</span> <span class="keyword">typename</span> deduct2&lt;E1, E2&gt;::real_type
<a name="l00153"></a><a class="code" href="vector_2function_8hpp.html#a1b24d6a708e5b93bf0170799a25fdd62">00153</a> <a class="code" href="vector_2function_8hpp.html#a1b24d6a708e5b93bf0170799a25fdd62" title="2点間の距離を返す関数">distance</a>(<a class="code" href="structvector__expression.html">vector_expression&lt;E1&gt;</a> <span class="keyword">const</span>&amp; e1, <a class="code" href="structvector__expression.html">vector_expression&lt;E2&gt;</a> <span class="keyword">const</span>&amp; e2){
<a name="l00154"></a>00154     <span class="keywordflow">return</span> <a class="code" href="vector_2function_8hpp.html#a54d5268004fe199763337f2179a7608e" title="ベクトル大きさを返す関数">nogara::expression::length</a>(e1 - e2);
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 
<a name="l00161"></a>00161 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E1, <span class="keyword">class</span> E2&gt;
<a name="l00162"></a>00162 <span class="keyword">inline</span> <span class="keyword">typename</span> deduct2&lt;E1, E2&gt;::real_type
<a name="l00163"></a><a class="code" href="vector_2function_8hpp.html#ac975cc065b1c036e2e224e1e5d3c7284">00163</a> <a class="code" href="vector_2function_8hpp.html#ac975cc065b1c036e2e224e1e5d3c7284" title="2つのベクトルの角度(ラジアン)を返す関数 なお、この関数に渡すベクトルは正規化されている必要がある">angle</a>(<a class="code" href="structvector__expression.html">vector_expression&lt;E1&gt;</a> <span class="keyword">const</span>&amp; e1, <a class="code" href="structvector__expression.html">vector_expression&lt;E2&gt;</a> <span class="keyword">const</span>&amp; e2){
<a name="l00164"></a>00164     <span class="keyword">typedef</span> <span class="keyword">typename</span> deduct2&lt;E1, E2&gt;::real_type real_t;
<a name="l00165"></a>00165     real_t <span class="keyword">const</span> <a class="code" href="vector_2function_8hpp.html#ac98bdedfa67670e68c93891a11aaf738" title="内積関数">dot</a> = <a class="code" href="vector_2function_8hpp.html#ac98bdedfa67670e68c93891a11aaf738" title="内積関数">nogara::expression::dot</a>(e1, e2);
<a name="l00166"></a>00166     real_t <span class="keyword">const</span> result = (dot &lt; -1) ? -1 : (dot &gt; 1) ? 1 : <a class="code" href="vector_2function_8hpp.html#ac98bdedfa67670e68c93891a11aaf738" title="内積関数">dot</a>;
<a name="l00167"></a>00167     <span class="keywordflow">return</span> std::acos(result);
<a name="l00168"></a>00168 }
<a name="l00169"></a>00169 
<a name="l00173"></a>00173 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E1, <span class="keyword">class</span> E2&gt;
<a name="l00174"></a>00174 <span class="keyword">inline</span> <span class="keyword">typename</span> deduct2&lt;E1, E2&gt;::real_type
<a name="l00175"></a><a class="code" href="vector_2function_8hpp.html#a058b8bb6a85b0544c9708031910208a0">00175</a> <a class="code" href="vector_2function_8hpp.html#a058b8bb6a85b0544c9708031910208a0" title="2つのベクトル正規化して角度(ラジアン)を返す関数">normalize_angle</a>(<a class="code" href="structvector__expression.html">vector_expression&lt;E1&gt;</a> <span class="keyword">const</span>&amp; e1, <a class="code" href="structvector__expression.html">vector_expression&lt;E2&gt;</a> <span class="keyword">const</span>&amp; e2){
<a name="l00176"></a>00176     <span class="keywordflow">return</span> <a class="code" href="vector_2function_8hpp.html#ac975cc065b1c036e2e224e1e5d3c7284" title="2つのベクトルの角度(ラジアン)を返す関数 なお、この関数に渡すベクトルは正規化されている必要がある">angle</a>(<a class="code" href="vector_2function_8hpp.html#a782a6eaae22a0aa615b1dfba1ce0ac58" title="ベクトルの正規化関数 0ベクトルが渡された場合は0ベクトルが返る">normalize</a>(e1), <a class="code" href="vector_2function_8hpp.html#a782a6eaae22a0aa615b1dfba1ce0ac58" title="ベクトルの正規化関数 0ベクトルが渡された場合は0ベクトルが返る">normalize</a>(e2));
<a name="l00177"></a>00177 }
<a name="l00178"></a>00178 
<a name="l00183"></a>00183 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E1, <span class="keyword">class</span> E2, <span class="keyword">typename</span> T&gt;
<a name="l00184"></a>00184 <span class="keyword">inline</span> <span class="keyword">typename</span> boost::enable_if&lt;
<a name="l00185"></a>00185     <a class="code" href="structsame__dimension.html" title="ベクトルの次元数が等しいかを返すメタ関数">same_dimension&lt;E1, E2&gt;</a>,
<a name="l00186"></a>00186     <a class="code" href="classapply__vector__binary.html">apply_vector_binary&lt;E1, E2, vector_lerp_functor&lt;T&gt;</a> &gt; &gt;<a class="code" href="classboost_1_1mpl_1_1if___1_1type.html">::type</a>
<a name="l00187"></a><a class="code" href="vector_2function_8hpp.html#a8540c4cd566481a1364f1f43fb613f8a">00187</a> <a class="code" href="scalar_2function_8hpp.html#aaea8f67c77d402672cdb3d41cf4f94be" title="線形補間">lerp</a>(<a class="code" href="structvector__expression.html">vector_expression&lt;E1&gt;</a> <span class="keyword">const</span>&amp; e1, <a class="code" href="structvector__expression.html">vector_expression&lt;E2&gt;</a> <span class="keyword">const</span>&amp; e2, T <span class="keyword">const</span>&amp; t){
<a name="l00188"></a>00188     <span class="keywordflow">return</span> apply(e1, e2, <a class="code" href="classvector__lerp__functor.html" title="線形補間を行う関数オブジェクト">vector_lerp_functor&lt;T&gt;</a>(t));
<a name="l00189"></a>00189 }
<a name="l00190"></a>00190 
<a name="l00196"></a>00196 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E1, <span class="keyword">class</span> E2, <span class="keyword">typename</span> T&gt;
<a name="l00197"></a>00197 <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="structvector__type.html" title="次元数と等しいベクトル型を返す 後に特殊化する">vector_type&lt;typename deduct3&lt;E1, E2, T&gt;::real_type</a>,
<a name="l00198"></a>00198                             <a class="code" href="structget__same__dimension.html" title="ベクトルの次元数が等しければその次元数を返し、 違っていればコンパイルエラーとするメタ関数">get_same_dimension&lt;E1, E2&gt;::value</a>&gt;<a class="code" href="classboost_1_1mpl_1_1if___1_1type.html">::type</a>
<a name="l00199"></a><a class="code" href="vector_2function_8hpp.html#abd5fe5824d3a39deacc4a994800dc815">00199</a> <a class="code" href="quaternion_2function_8hpp.html#ad8c211c7830fb15867561118c2e76184" title="球面線形補間">slerp</a>(<a class="code" href="structvector__expression.html">vector_expression&lt;E1&gt;</a> <span class="keyword">const</span>&amp; e1, <a class="code" href="structvector__expression.html">vector_expression&lt;E2&gt;</a> <span class="keyword">const</span>&amp; e2, T <span class="keyword">const</span>&amp; t){
<a name="l00200"></a>00200     <span class="keyword">typedef</span> <span class="keyword">typename</span> deduct2&lt;E1, E2&gt;::real_type real_t;
<a name="l00201"></a>00201     real_t <span class="keyword">const</span> <a class="code" href="vector_2function_8hpp.html#ac975cc065b1c036e2e224e1e5d3c7284" title="2つのベクトルの角度(ラジアン)を返す関数 なお、この関数に渡すベクトルは正規化されている必要がある">angle</a> = <a class="code" href="vector_2function_8hpp.html#ac975cc065b1c036e2e224e1e5d3c7284" title="2つのベクトルの角度(ラジアン)を返す関数 なお、この関数に渡すベクトルは正規化されている必要がある">nogara::expression::angle</a>(e1, e2);
<a name="l00202"></a>00202     real_t <span class="keyword">const</span> start = std::sin(angle * (1 - t));
<a name="l00203"></a>00203     real_t <span class="keyword">const</span> end   = std::sin(angle * t);
<a name="l00204"></a>00204 
<a name="l00205"></a>00205     <span class="keywordflow">return</span> <a class="code" href="vector_2function_8hpp.html#a782a6eaae22a0aa615b1dfba1ce0ac58" title="ベクトルの正規化関数 0ベクトルが渡された場合は0ベクトルが返る">normalize</a>((start * e1 + end * e2) / std::sin(angle));
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 
<a name="l00211"></a>00211 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> T&gt;
<a name="l00212"></a>00212 <span class="keyword">inline</span> <span class="keyword">typename</span> boost::enable_if&lt;
<a name="l00213"></a>00213     boost::mpl::and_&lt;boost::mpl::not_&lt;is_quaternion&lt;E&gt; &gt;, <a class="code" href="structis__scalar.html" title="Eがスカラであるかを返すメタ関数">is_scalar&lt;T&gt;</a> &gt;,
<a name="l00214"></a>00214     <a class="code" href="classapply__vector__unary.html">apply_vector_unary&lt;E, pow_functor&lt;T&gt;</a> &gt; &gt;<a class="code" href="classboost_1_1mpl_1_1if___1_1type.html">::type</a>
<a name="l00215"></a><a class="code" href="vector_2function_8hpp.html#a24c2b557c254bca68777b73faccf8ce6">00215</a> <a class="code" href="quaternion_2function_8hpp.html#a580259637c5aa588897d06da495a43e4" title="クォータニオンの冪乗">pow</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; e, T <span class="keyword">const</span>&amp; t){
<a name="l00216"></a>00216     <span class="keywordflow">return</span> apply(e, <a class="code" href="classpow__functor.html" title="ベクトルの冪乗を行う関数オブジェクト">pow_functor&lt;T&gt;</a>(t));
<a name="l00217"></a>00217 }
<a name="l00218"></a>00218 
<a name="l00223"></a>00223 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E&gt;
<a name="l00224"></a>00224 <span class="keyword">inline</span> <a class="code" href="classvector__and__scalar.html" title="左辺がベクトル、右辺がスカラの演算を行うクラス">vector_and_scalar</a>&lt;
<a name="l00225"></a>00225     E, <span class="keyword">typename</span> deduct1&lt;E&gt;::real_type, scalar_mul&lt;E, typename deduct1&lt;E&gt;::real_type&gt; &gt;
<a name="l00226"></a><a class="code" href="vector_2function_8hpp.html#a782a6eaae22a0aa615b1dfba1ce0ac58">00226</a> <a class="code" href="vector_2function_8hpp.html#a782a6eaae22a0aa615b1dfba1ce0ac58" title="ベクトルの正規化関数 0ベクトルが渡された場合は0ベクトルが返る">normalize</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; e){
<a name="l00227"></a>00227     <span class="keyword">typedef</span> <span class="keyword">typename</span> deduct1&lt;E&gt;::real_type real_type;
<a name="l00228"></a>00228     real_type <a class="code" href="vector_2function_8hpp.html#a54d5268004fe199763337f2179a7608e" title="ベクトル大きさを返す関数">length</a> = <a class="code" href="vector_2function_8hpp.html#a54d5268004fe199763337f2179a7608e" title="ベクトル大きさを返す関数">nogara::expression::length</a>(e);
<a name="l00229"></a>00229     <span class="keywordflow">if</span>(length != real_type()){
<a name="l00230"></a>00230         length = real_type(1) / <a class="code" href="vector_2function_8hpp.html#a54d5268004fe199763337f2179a7608e" title="ベクトル大きさを返す関数">length</a>;
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232     <span class="keywordflow">return</span> e * <a class="code" href="vector_2function_8hpp.html#a54d5268004fe199763337f2179a7608e" title="ベクトル大きさを返す関数">length</a>;
<a name="l00233"></a>00233 }
<a name="l00234"></a>00234 
<a name="l00238"></a>00238 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E&gt;
<a name="l00239"></a>00239 <span class="keyword">inline</span> <span class="keyword">typename</span> boost::disable_if&lt;
<a name="l00240"></a>00240     <a class="code" href="structis__quaternion.html" title="式Eがクォータニオンであるかを返すメタ関数">is_quaternion&lt;E&gt;</a>, <a class="code" href="classvector__unary.html" title="単項演算クラス 第3テンプレート引数は static T apply(T const&amp;amp;)という クラスメソッドを持つ必要がある">vector_unary&lt;E, scalar_inverse&lt;E&gt;</a> &gt; &gt;<a class="code" href="classboost_1_1mpl_1_1if___1_1type.html">::type</a>
<a name="l00241"></a><a class="code" href="vector_2function_8hpp.html#aba83138e9f073b0956a794aad178f30e">00241</a> <a class="code" href="matrix_2function_8hpp.html#a12afb7b086762dbc23e180595c6fc82b" title="4 * 4行列の逆行列を返す関数">inverse</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; e){
<a name="l00242"></a>00242     <span class="keywordflow">return</span> <a class="code" href="classvector__unary.html" title="単項演算クラス 第3テンプレート引数は static T apply(T const&amp;amp;)という クラスメソッドを持つ必要がある">vector_unary&lt;E, scalar_inverse&lt;E&gt;</a> &gt;(e);
<a name="l00243"></a>00243 }
<a name="l00244"></a>00244 
<a name="l00249"></a>00249 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E1, <span class="keyword">class</span> E2&gt;
<a name="l00250"></a>00250 <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="structvector__type.html" title="次元数と等しいベクトル型を返す 後に特殊化する">vector_type</a>&lt;
<a name="l00251"></a>00251     <span class="keyword">typename</span> deduct2&lt;E1, E2&gt;::value_type, <a class="code" href="structget__same__dimension.html" title="ベクトルの次元数が等しければその次元数を返し、 違っていればコンパイルエラーとするメタ関数">get_same_dimension&lt;E1, E2&gt;::value</a>&gt;<a class="code" href="classboost_1_1mpl_1_1if___1_1type.html">::type</a>
<a name="l00252"></a><a class="code" href="vector_2function_8hpp.html#aebae09ad9441178b3b04b546ef9cdf58">00252</a> <a class="code" href="vector_2function_8hpp.html#aebae09ad9441178b3b04b546ef9cdf58" title="反射ベクトル この関数の第二引数は正規化されている必要がある">reflect</a>(<a class="code" href="structvector__expression.html">vector_expression&lt;E1&gt;</a> <span class="keyword">const</span>&amp; incident, <a class="code" href="structvector__expression.html">vector_expression&lt;E2&gt;</a> <span class="keyword">const</span>&amp; normal){
<a name="l00253"></a>00253     <span class="keywordflow">return</span> <a class="code" href="vector_2function_8hpp.html#a782a6eaae22a0aa615b1dfba1ce0ac58" title="ベクトルの正規化関数 0ベクトルが渡された場合は0ベクトルが返る">expression::normalize</a>(incident - 2 * <a class="code" href="vector_2function_8hpp.html#ac98bdedfa67670e68c93891a11aaf738" title="内積関数">expression::dot</a>(incident, normal) * normal);
<a name="l00254"></a>00254 }
<a name="l00255"></a>00255 
<a name="l00259"></a>00259 <span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> E&gt;
<a name="l00260"></a><a class="code" href="vector_2function_8hpp.html#a1e1e38edda3cb3bfa9bead0c6eb50f65">00260</a> <span class="keyword">inline</span> <a class="code" href="classvector__unary.html" title="単項演算クラス 第3テンプレート引数は static T apply(T const&amp;amp;)という クラスメソッドを持つ必要がある">vector_unary&lt;E, F&gt;</a> <a class="code" href="vector_2function_8hpp.html#ad72e55a15a28419b63f7d2a6902b0213" title="第二引数の関数ポインタをベクトルに適応する関数">map</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; e){
<a name="l00261"></a>00261     <span class="keywordflow">return</span> <a class="code" href="classvector__unary.html" title="単項演算クラス 第3テンプレート引数は static T apply(T const&amp;amp;)という クラスメソッドを持つ必要がある">vector_unary&lt;E, F&gt;</a>(e);
<a name="l00262"></a>00262 }
<a name="l00263"></a>00263 
<a name="l00267"></a>00267 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> F&gt;
<a name="l00268"></a><a class="code" href="vector_2function_8hpp.html#ac30884251bfe7d93e20faec0498c8c51">00268</a> <span class="keyword">inline</span> <a class="code" href="classapply__vector__unary.html">apply_vector_unary&lt;E, F&gt;</a> <a class="code" href="vector_2function_8hpp.html#ad72e55a15a28419b63f7d2a6902b0213" title="第二引数の関数ポインタをベクトルに適応する関数">map</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; e, F f){
<a name="l00269"></a>00269     <span class="keywordflow">return</span> apply(e, f);
<a name="l00270"></a>00270 }
<a name="l00271"></a>00271 
<a name="l00275"></a>00275 <span class="keyword">template</span>&lt;<span class="keyword">class</span> R, <span class="keyword">class</span> A, <span class="keyword">class</span> E&gt;
<a name="l00276"></a><a class="code" href="vector_2function_8hpp.html#ad72e55a15a28419b63f7d2a6902b0213">00276</a> <span class="keyword">inline</span> <a class="code" href="classapply__vector__unary.html">apply_vector_unary&lt;E, R(*)(A)&gt;</a> <a class="code" href="vector_2function_8hpp.html#ad72e55a15a28419b63f7d2a6902b0213" title="第二引数の関数ポインタをベクトルに適応する関数">map</a>(<a class="code" href="structvector__expression.html" title="ベクトル式の基礎となるクラス">vector_expression&lt;E&gt;</a> <span class="keyword">const</span>&amp; e, R (*f)(A)){
<a name="l00277"></a>00277     <span class="keywordflow">return</span> apply(e, f);
<a name="l00278"></a>00278 }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 __NOGARA_EXPRESSION_END
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 __NOGARA_BEGIN
<a name="l00284"></a>00284 <span class="keyword">using</span> <a class="code" href="matrix_2function_8hpp.html#a2dc5342ff07e7ce42d02db73e24f62e2" title="テンプレート引数で指定した要素を返す関数 インデックス値は行列の行サイズ、列サイズ未満である必要がある">expression::get</a>;
<a name="l00285"></a>00285 <span class="keyword">using</span> <a class="code" href="matrix_2function_8hpp.html#aa7b8b9cf669bb5ce3b6f90b1172b0cc1" title="式の三項演算関数、式は評価される">expression::ternary</a>;
<a name="l00286"></a>00286 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#a326fb720c990be8264d819cf88c114b6" title="ベクトルの値それぞれを絶対値にしたベクトルを返す関数">expression::abs</a>;
<a name="l00287"></a>00287 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#aec6e88d2bdf5259da50482edfc75b3c6" title="ベクトルの合計を返す関数">expression::sum</a>;
<a name="l00288"></a>00288 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#ac2900d0e7ae939f67fad07aebfe2a432" title="ベクトルの値から最大値を返す関数">expression::max</a>;
<a name="l00289"></a>00289 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#ac98bdedfa67670e68c93891a11aaf738" title="内積関数">expression::dot</a>;
<a name="l00290"></a>00290 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#a54d5268004fe199763337f2179a7608e" title="ベクトル大きさを返す関数">expression::length</a>;
<a name="l00291"></a>00291 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#a885888cb99ca98818df7dd40abbe13a2" title="ベクトルの大きさの二乗を返す関数">expression::length_sq</a>;
<a name="l00292"></a>00292 <span class="keyword">using</span> <a class="code" href="scalar_2function_8hpp.html#aaea8f67c77d402672cdb3d41cf4f94be" title="線形補間">expression::lerp</a>;
<a name="l00293"></a>00293 <span class="keyword">using</span> <a class="code" href="quaternion_2function_8hpp.html#ad8c211c7830fb15867561118c2e76184" title="球面線形補間">expression::slerp</a>;
<a name="l00294"></a>00294 <span class="keyword">using</span> <a class="code" href="quaternion_2function_8hpp.html#a580259637c5aa588897d06da495a43e4" title="クォータニオンの冪乗">expression::pow</a>;
<a name="l00295"></a>00295 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#a969104624180693e480251a38ba55eb4" title="外積関数">expression::cross</a>;
<a name="l00296"></a>00296 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#a782a6eaae22a0aa615b1dfba1ce0ac58" title="ベクトルの正規化関数 0ベクトルが渡された場合は0ベクトルが返る">expression::normalize</a>;
<a name="l00297"></a>00297 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#a1b24d6a708e5b93bf0170799a25fdd62" title="2点間の距離を返す関数">expression::distance</a>;
<a name="l00298"></a>00298 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#ac975cc065b1c036e2e224e1e5d3c7284" title="2つのベクトルの角度(ラジアン)を返す関数 なお、この関数に渡すベクトルは正規化されている必要がある">expression::angle</a>;
<a name="l00299"></a>00299 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#a058b8bb6a85b0544c9708031910208a0" title="2つのベクトル正規化して角度(ラジアン)を返す関数">expression::normalize_angle</a>;
<a name="l00300"></a>00300 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#a7cec8ed4a1cf975a46f92a23b4865725" title="要素同士の乗算関数">expression::multiply</a>;
<a name="l00301"></a>00301 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#af9c11b7750e12b5e442517c266c77cfe" title="要素同士の除算関数">expression::divide</a>;
<a name="l00302"></a>00302 <span class="keyword">using</span> <a class="code" href="matrix_2function_8hpp.html#a12afb7b086762dbc23e180595c6fc82b" title="4 * 4行列の逆行列を返す関数">expression::inverse</a>;
<a name="l00303"></a>00303 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#aebae09ad9441178b3b04b546ef9cdf58" title="反射ベクトル この関数の第二引数は正規化されている必要がある">expression::reflect</a>;
<a name="l00304"></a>00304 <span class="keyword">using</span> <a class="code" href="vector_2function_8hpp.html#ad72e55a15a28419b63f7d2a6902b0213" title="第二引数の関数ポインタをベクトルに適応する関数">expression::map</a>;
<a name="l00305"></a>00305 __NOGARA_END
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>全て</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>クラス</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>ネームスペース</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>ファイル</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>関数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>変数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>型定義</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>列挙型</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Nogaraに対してFri Apr 29 2011 06:49:44に生成されました。&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
